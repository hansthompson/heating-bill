read.csv("heating_data.csv")
library(ggplot2)
paste(dat$month, year)
dat <- read.csv("heating_data.csv")
paste(dat$month, dat$year)
my
library(ggplot2)
library(lubridate)
my
ym
ymd
ymd(paste(dat$month, dat$year))
?ymd
ymd(paste(dat$month, dat$year), "%B %Y!")
parse_date_time(paste(dat$month, dat$year), "%B %Y!")
paste(dat$month, dat$year)
parse_date_time(paste(dat$month, dat$year), "%B %Y!")
Sys.time()
parse_date_time(paste(dat$month, dat$year, sep = "-"), "%B-%Y!")
(paste(dat$month, dat$year)
paste(dat$month, dat$year)
dat <- read.csv("heating_data.csv")
dat
parse_date_time(paste(dat$month, dat$year), "%m*! %Y!")
date <- parse_date_time(paste(dat$month, dat$year), "%m*! %Y!")
dat <- cbind(dat, date)
ggplot(data = dat, aes(x = use / days, y = mean_temp)) + geom+point()
ggplot(data = dat, aes(x = use / days, y = mean_temp)) + geom_point()
ggplot(data = dat, aes(x = use / days, y = mean_temp), color = year) + geom_point()
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = year)) + geom_point()
dat$year <- factor(dat$year)
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = year)) + geom_point()
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = year)) + geom_line()
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = year)) + geom_line() + geom_point()
dat <- read.csv("heating_data.csv")
date <- parse_date_time(paste(dat$month, dat$year), "%m*! %Y!")
dat$year <- factor(dat$year)
dat <- cbind(dat, date)
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = owner)) + geom_line() + geom_point()
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = owner)) + geom_line() + geom_point() + geom_smooth()
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = owner))+ geom_point() + geom_smooth()
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line()
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = owner))+ geom_point() + geom_smooth()
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = energy_remodel))+ geom_point() + geom_smooth()
dat <- read.csv("heating_data.csv")
date <- parse_date_time(paste(dat$month, dat$year), "%m*! %Y!")
dat$year <- factor(dat$year)
dat <- cbind(dat, date)
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = energy_remodel))+ geom_point() + geom_smooth()
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line(method = "lm")
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = energy_remodel))+ geom_point() + geom_smooth(method = "lm")
?geom_smooth
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line()
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = energy_remodel))+ geom_point() + geom_smooth(method = "lm")
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line()
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = energy_remodel))+ geom_point() + geom_smooth(method = "lm")
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = energy_remodel))+ geom_point(size = 3) + geom_smooth(method = "lm")
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line()
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line() + geom_line(data = dat, aes(x = date, y = mean_temp))
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line()
theme(axis.title.x = "Time",
axis.title.y = "ccf",)
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line() +
theme(axis.title.x = "Time",
axis.title.y = "mean ccf",)
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line() +
theme(axis.title.x = "Time",
axis.title.y = "mean ccf")
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line() +
theme(xlab = "Time",
tlab = "mean ccf")
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line() +
labs(x= "Time",
y = "mean ccf")
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line() +
labs(x= "Time",
y = "Mean Ccf")
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line() +
labs(x= "Time",
y = "Mean Ccf",
Title = "Gas useage in ccf over time")
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line() +
labs(x= "Time",
y = "Mean Ccf",
title = "Gas useage in ccf over time")
ggplot(data = dat, aes(x = use / days, y = mean_temp, color = energy_remodel))+ geom_point(size = 3) + geom_smooth(method = "lm") +
labs(x= "Time",
y = "Mean Ccf",
title = "Gas useage in ccf over time")
ggplot(data = dat, aes(x = mean_temp, y = use / days, color = energy_remodel))+ geom_point(size = 3) + geom_smooth(method = "lm") +
labs(x= "Mean Temperature",
y = "Mean Ccf",
title = "Gas useage in ccf over time")
ggplot(data = dat, aes(x = mean_temp, y = use / days, color = energy_remodel))+ geom_point(size = 3) + geom_smooth(method = "lm") +
labs(x= "Mean Temperature",
y = "Mean Ccf",
title = "Average energy consumtion over outside temperature")
ggplot(data = dat, aes(x = date, y = use/days)) + geom_line() +
labs(x= "Time",
y = "Mean Ccf",
title = "Gas useage in ccf over time")
ggplot(data = dat, aes(x = mean_temp, y = use / days, color = energy_remodel))+ geom_point(size = 3) + geom_smooth(method = "lm") +
labs(x= "Mean Temperature",
y = "Mean Ccf",
title = "Average energy consumtion over outside temperature")
ggplot(data = dat, aes(x = mean_temp, y = use / days, color = energy_remodel))+ geom_point(size = 3) + geom_smooth(method = "lm", se = FALSE) +
labs(x= "Mean Temperature",
y = "Mean Ccf",
title = "Average energy consumtion over outside temperature")
send(`__name__`, sys.function(), as.list(environment()))
??send
`__name__`
as.list(environment())
#' @export
createLeafletMap <- function(session, outputId) {
# Need to provide some trivial output, just to get the binding to render
session$output[[outputId]] <- renderText("")
# This function is how we "dynamically" invoke code on the client. The
# method parameter indicates what leaflet operation we want to perform,
# and the other arguments will be serialized to JS objects and used as
# client side function args.
send <- function(method, func, msg) {
msg <- msg[names(formals(func))]
names(msg) <- NULL
origDigits <- getOption('digits')
options(digits=22)
on.exit(options(digits=origDigits))
session$sendCustomMessage('leaflet', list(
mapId = outputId,
method = method,
args = msg
))
}
baseimpl <- function() {
send(`__name__`, sys.function(), as.list(environment()))
}
# Turns a call like:
#
# stub(setView(lat, lng, zoom, forceReset = FALSE))
#
# into:
#
# list(setView = function(lat, lng, zoom, forceReset = FALSE) {
# send("setView", sys.function(), as.list(environment()))
# })
stub <- function(prototype) {
# Get the un-evaluated expression
p <- substitute(prototype)
# The function name is the first element
name <- as.character(p[[1]])
# Get textual representation of the expression; change name to "function"
# and add a NULL function body
txt <- paste(deparse(p), collapse = "\n")
txt <- sub(name, "function", txt, fixed = TRUE)
txt <- paste0(txt, "NULL")
# Create the function
func <- eval(parse(text = txt))
# Replace the function body, using baseimpl's body as a template
body(func) <- substituteDirect(
body(baseimpl),
as.environment(list("__name__"=name))
)
environment(func) <- environment(baseimpl)
# Return as list
structure(list(func), names = name)
}
structure(c(
stub(setView(lat, lng, zoom, forceReset = FALSE)),
stub(addMarker(lat, lng, layerId=NULL, options=list(), eachOptions=list())),
stub(addCircleMarker(lat, lng, radius, layerId = NULL, options = list(), eachOptions=list())),
stub(clearMarkers()),
stub(fitBounds(lat1, lng1, lat2, lng2)),
stub(addCircle(lat, lng, radius, layerId = NULL, options=list(), eachOptions=list())),
stub(addRectangle(lat1, lng1, lat2, lng2, layerId = NULL, options=list(), eachOptions=list())),
stub(addPolygon(lat, lng, layerId, options, defaultOptions)),
stub(addGeoJSON(data, layerId)),
stub(clearGeoJSON()),
stub(showPopup(lat, lng, content, layerId = NULL, options=list())),
stub(removePopup(layerId)),
stub(clearPopups()),
stub(removeShape(layerId)),
stub(clearShapes()),
stub(removeMarker(layerId)),
stub(clearMarkers())
), class = "leaflet_map")
}
#' @export
leafletMap <- function(
outputId, width, height,
initialTileLayer = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
initialTileLayerAttribution = HTML('&copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'),
options=NULL) {
addResourcePath("leaflet", system.file("www", package="leaflet"))
if (is.numeric(width))
width <- sprintf("%dpx", width)
if (is.numeric(height))
height <- sprintf("%dpx", height)
tagList(
singleton(
tags$head(
tags$link(rel="stylesheet", type="text/css", href="leaflet/leaflet.css"),
tags$script(src="leaflet/leaflet.js"),
tags$script(src="leaflet/binding.js")
)
),
tags$div(
id = outputId, class = "leaflet-map-output",
style = sprintf("width: %s; height: %s", width, height),
`data-initial-tile-layer` = initialTileLayer,
`data-initial-tile-layer-attrib` = initialTileLayerAttribution,
tags$script(
type="application/json", class="leaflet-options",
ifelse(is.null(options), "{}", RJSONIO::toJSON(options))
)
)
)
}
formals(c)
formals(c())
formals(sys.function())
formals(sys.function
)
names(formals(sys.function)
)
names(formals(sys.function)
names(formals(sys.function))
as.list(environment())[names(formals(sys.function))]
?stub
baseimpl()
#' @export
createLeafletMap <- function(session, outputId) {
# Need to provide some trivial output, just to get the binding to render
session$output[[outputId]] <- renderText("")
# This function is how we "dynamically" invoke code on the client. The
# method parameter indicates what leaflet operation we want to perform,
# and the other arguments will be serialized to JS objects and used as
# client side function args.
send <- function(method, func, msg) {
msg <- msg[names(formals(func))]
names(msg) <- NULL
origDigits <- getOption('digits')
options(digits=22)
on.exit(options(digits=origDigits))
session$sendCustomMessage('leaflet', list(
mapId = outputId,
method = method,
args = msg
))
}
baseimpl <- function() {
send(`__name__`, sys.function(), as.list(environment()))
}
# Turns a call like:
#
# stub(setView(lat, lng, zoom, forceReset = FALSE))
#
# into:
#
# list(setView = function(lat, lng, zoom, forceReset = FALSE) {
# send("setView", sys.function(), as.list(environment()))
# })
stub <- function(prototype) {
# Get the un-evaluated expression
p <- substitute(prototype)
# The function name is the first element
name <- as.character(p[[1]])
# Get textual representation of the expression; change name to "function"
# and add a NULL function body
txt <- paste(deparse(p), collapse = "\n")
txt <- sub(name, "function", txt, fixed = TRUE)
txt <- paste0(txt, "NULL")
# Create the function
func <- eval(parse(text = txt))
# Replace the function body, using baseimpl's body as a template
body(func) <- substituteDirect(
body(baseimpl),
as.environment(list("__name__"=name))
)
environment(func) <- environment(baseimpl)
# Return as list
structure(list(func), names = name)
}
structure(c(
stub(setView(lat, lng, zoom, forceReset = FALSE)),
stub(addMarker(lat, lng, layerId=NULL, options=list(), eachOptions=list())),
stub(addCircleMarker(lat, lng, radius, layerId = NULL, options = list(), eachOptions=list())),
stub(clearMarkers()),
stub(fitBounds(lat1, lng1, lat2, lng2)),
stub(addCircle(lat, lng, radius, layerId = NULL, options=list(), eachOptions=list())),
stub(addRectangle(lat1, lng1, lat2, lng2, layerId = NULL, options=list(), eachOptions=list())),
stub(addPolygon(lat, lng, layerId, options, defaultOptions)),
stub(addGeoJSON(data, layerId)),
stub(clearGeoJSON()),
stub(showPopup(lat, lng, content, layerId = NULL, options=list())),
stub(removePopup(layerId)),
stub(clearPopups()),
stub(removeShape(layerId)),
stub(clearShapes()),
stub(removeMarker(layerId)),
stub(clearMarkers())
), class = "leaflet_map")
}
#' @export
leafletMap <- function(
outputId, width, height,
initialTileLayer = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
initialTileLayerAttribution = HTML('&copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'),
options=NULL) {
addResourcePath("leaflet", system.file("www", package="leaflet"))
if (is.numeric(width))
width <- sprintf("%dpx", width)
if (is.numeric(height))
height <- sprintf("%dpx", height)
tagList(
singleton(
tags$head(
tags$link(rel="stylesheet", type="text/css", href="leaflet/leaflet.css"),
tags$script(src="leaflet/leaflet.js"),
tags$script(src="leaflet/binding.js")
)
),
tags$div(
id = outputId, class = "leaflet-map-output",
style = sprintf("width: %s; height: %s", width, height),
`data-initial-tile-layer` = initialTileLayer,
`data-initial-tile-layer-attrib` = initialTileLayerAttribution,
tags$script(
type="application/json", class="leaflet-options",
ifelse(is.null(options), "{}", RJSONIO::toJSON(options))
)
)
)
}
baseimpl()
?shiny
library(shiny)
?leafletMap
library(ShinyDash)
library(leaflet)
